'slMF.twin - Media Foundation interfaces

    [ InterfaceId ("90377834-21D0-4DEE-8214-BA2E3E6C1127") ]
    [ OleAutomation (False) ]
    Interface IMFMediaSession Extends IMFMediaEventGenerator
        Sub SetTopology(ByVal dwSetTopologyFlags As Long, ByVal pTopology As IMFTopology)
        Sub ClearTopologies()
        Sub Start(ByRef pguidTimeFormat As UUID, ByRef pvarStartPosition As Variant)
        Sub Pause()
        Sub Stop()
        Sub Close()
        Sub Shutdown()
        Sub GetClock(ByRef ppClock As IMFClock)
        Sub GetSessionCapabilities(ByRef pdwCaps As Long)
        Sub GetFullTopology(ByVal dwGetFullTopologyFlags As Long, ByVal TopoId As LongLong, ByRef ppFullTopology As IMFTopology)
    End Interface
    
    [ InterfaceId ("FBE5A32D-A497-4B61-BB85-97B1A848A6E3") ]
    [ OleAutomation (False) ]
    Interface IMFSourceResolver Extends stdole.IUnknown
        Function CreateObjectFromURL(ByVal pwszUrl As LongPtr, ByVal dwFlags As Long, ByVal pProps As IPropertyStore, ByRef pObjectType As MF_OBJECT_TYPE) As IUnknown
        Function CreateObjectFromByteStream(ByVal pByteStream As IMFByteStream, ByVal pwszUrl As LongPtr, ByVal dwFlags As Long, ByVal pProps As IPropertyStore, ByRef pObjectType As MF_OBJECT_TYPE) As IUnknown
        Sub BeginCreateObjectFromURL(ByVal pwszUrl As LongPtr, ByVal dwFlags As Long, ByVal pProps As IPropertyStore, ByRef ppIUnknownCancelCookie As IUnknown, ByVal pCallback As IMFAsyncCallback, ByVal punkState As IUnknown)
        Function EndCreateObjectFromURL(ByVal pResult As IMFAsyncResult, ByRef pObjectType As MF_OBJECT_TYPE) As IUnknown
        Sub BeginCreateObjectFromByteStream(ByVal pByteStream As IMFByteStream, ByVal pwszUrl As LongPtr, ByVal dwFlags As Long, ByVal pProps As IPropertyStore, ByRef ppIUnknownCancelCookie As IUnknown, ByVal pCallback As IMFAsyncCallback, ByVal punkState As IUnknown)
        Function EndCreateObjectFromByteStream(ByVal pResult As IMFAsyncResult, ByRef pObjectType As MF_OBJECT_TYPE) As IUnknown
        Sub CancelObjectCreation(ByVal pIUnknownCancelCookie As IUnknown)
    End Interface

    [ InterfaceId ("AD4C1B00-4BF7-422F-9175-756693D9130D") ]
    [ OleAutomation (False) ]
    Interface IMFByteStream Extends stdole.IUnknown
        Function GetCapabilities() As Long
        Function GetLength() As LongLong
        Sub SetLength(ByVal qwLength As LongLong)
        Function GetCurrentPosition() As LongLong
        Sub SetCurrentPosition(ByVal qwPosition As LongLong)
        Function IsEndOfStream() As Long
        Function Read(ByRef pb As Any, ByVal cb As Long) As Long
        Sub BeginRead(ByRef pb As Any, ByVal cb As Long, ByVal pCallback As IMFAsyncCallback, ByVal punkState As IUnknown)
        Function EndRead(ByVal pResult As IMFAsyncResult) As Long
        Function Write(ByRef pb As Any, ByVal cb As Long) As Long
        Sub BeginWrite(ByRef pb As Any, ByVal cb As Long, ByVal pCallback As IMFAsyncCallback, ByVal punkState As IUnknown)
        Function EndWrite(ByVal pResult As IMFAsyncResult) As Long
        Function Seek(ByVal SeekOrigin As MFBYTESTREAM_SEEK_ORIGIN, ByVal llSeekOffset As LongLong, ByVal dwSeekFlags As Long) As LongLong
        Sub Flush()
        Sub Close()
    End Interface

    [ InterfaceId ("A27003CF-2354-4F2A-8D6A-AB7CFF15437E") ]
    [ OleAutomation (False) ]
    Interface IMFAsyncCallback Extends stdole.IUnknown
        Sub GetParameters(ByRef pdwFlags As Long, ByRef pdwQueue As Long)
        Sub Invoke(ByVal pAsyncResult As IMFAsyncResult)
    End Interface

    [ InterfaceId ("AC6B7889-0740-4D51-8619-905994A55CC6") ]
    [ OleAutomation (False) ]
    Interface IMFAsyncResult Extends stdole.IUnknown
        Function GetState() As IUnknown
        [ PreserveSig ]
        Function GetStatus() As Long
        Sub SetStatus(ByVal hrStatus As Long)
        Function GetObject() As IUnknown
        [ PreserveSig ]
        Function GetStateNoAddRef() As IUnknown
    End Interface

    [ InterfaceId ("2CD2D921-C447-44A7-A13C-4ADABFC247E3") ]
    [ OleAutomation (False) ]
    Interface IMFAttributes Extends stdole.IUnknown
        Sub GetItem(ByRef guidKey As UUID, ByRef pValue As Any)
        Function GetItemType(ByRef guidKey As UUID) As MF_ATTRIBUTE_TYPE
        Function CompareItem(ByRef guidKey As UUID, ByRef Value As Variant) As Long
        Function Compare(ByVal pTheirs As IMFAttributes, ByVal MatchType As MF_ATTRIBUTES_MATCH_TYPE) As Long
        Function GetUInt32(ByRef guidKey As UUID) As Long
        Function GetUInt64(ByRef guidKey As UUID) As LongLong
        Function GetDouble(ByRef guidKey As UUID) As Double
        Function GetGUID(ByRef guidKey As UUID) As UUID
        Function GetStringLength(ByRef guidKey As UUID) As Long
        Function GetString(ByRef guidKey As UUID, ByVal pwszValue As LongPtr, ByVal cchBufSize As Long) As Long
        Function GetAllocatedString(ByRef guidKey As UUID, ByRef ppwszValue As Any) As Long
        Function GetBlobSize(ByRef guidKey As UUID) As Long
        Function GetBlob(ByRef guidKey As UUID, ByRef pBuf As Any, ByVal cbBufSize As Long) As Long
        Function GetAllocatedBlob(ByRef guidKey As UUID, ByRef ppBuf As Any) As Long
        Function GetUnknown(ByRef guidKey As UUID, ByRef riid As UUID) As IUnknown
        Sub SetItem(ByRef guidKey As UUID, ByRef Value As Variant)
        Sub DeleteItem(ByRef guidKey As UUID)
        Sub DeleteAllItems()
        Sub SetUINT32(ByRef guidKey As UUID, ByVal unValue As Long)
        Sub SetUINT64(ByRef guidKey As UUID, ByVal unValue As LongLong)
        Sub SetDouble(ByRef guidKey As UUID, ByVal fValue As Double)
        Sub SetGuid(ByRef guidKey As UUID, ByRef guidValue As UUID)
        Sub SetString(ByRef guidKey As UUID, ByVal wszValue As LongPtr)
        Sub SetBlob(ByRef guidKey As UUID, ByRef pBuf As Any, ByVal cbBufSize As Long)
        Sub SetUnknown(ByRef guidKey As UUID, ByVal pUnknown As IUnknown)
        Sub LockStore()
        Sub UnlockStore()
        Function GetCount() As Long
        Sub GetItemByIndex(ByVal unIndex As Long, ByRef pguidKey As UUID, ByRef pValue As Any)
        Sub CopyAllItems(ByVal pDest As IMFAttributes)
    End Interface


    [ InterfaceId ("2CD0BD52-BCD5-4B89-B62C-EADC0C031E7D") ]
    [ OleAutomation (False) ]
    Interface IMFMediaEventGenerator Extends stdole.IUnknown
        Function GetEvent(ByVal dwFlags As Long) As IMFMediaEvent
        Sub BeginGetEvent(ByVal pCallback As IMFAsyncCallback, ByVal punkState As IUnknown)
        Function EndGetEvent(ByVal pResult As IMFAsyncResult) As IMFMediaEvent
        Sub QueueEvent(ByVal met As MediaEventType, ByRef guidExtendedType As UUID, ByVal hrStatus As Long, ByRef pvValue As Any)
    End Interface

    [ InterfaceId ("DF598932-F10C-4E39-BBA2-C308F101DAA3") ]
    [ OleAutomation (False) ]
    Interface IMFMediaEvent Extends IMFAttributes
        Function GetType() As MediaEventType
        Function GetExtendedType() As UUID
        Function GetStatus() As Long
        Function GetValue() As Variant
    End Interface

    [ InterfaceId ("279A808D-AEC7-40C8-9C6B-A6B492C78A66") ]
    [ OleAutomation (False) ]
    Interface IMFMediaSource Extends IMFMediaEventGenerator
        Function GetCharacteristics() As Long
        Function CreatePresentationDescriptor() As IMFPresentationDescriptor
        Sub Start(ByVal pPresentationDescriptor As IMFPresentationDescriptor, ByRef pguidTimeFormat As Any, ByRef pvarStartPosition As Any)
        Sub Stop()
        Sub Pause()
        Sub Shutdown()
    End Interface

    [ InterfaceId ("03CB2711-24D7-4DB6-A17F-F3A7A479A536") ]
    [ OleAutomation (False) ]
    Interface IMFPresentationDescriptor Extends IMFAttributes
        Function GetStreamDescriptorCount() As Long
        Function GetStreamDescriptorByIndex(ByVal dwIndex As Long, ByRef pfSelected As Long) As IMFStreamDescriptor
        Sub SelectStream(ByVal dwDescriptorIndex As Long)
        Sub DeselectStream(ByVal dwDescriptorIndex As Long)
        Function Clone() As IMFPresentationDescriptor
    End Interface

    [ InterfaceId ("56C03D9C-9DBB-45F5-AB4B-D80F47C05938") ]
    [ OleAutomation (False) ]
    Interface IMFStreamDescriptor Extends IMFAttributes
        Function GetStreamIdentifier() As Long
        Function GetMediaTypeHandler() As IMFMediaTypeHandler
    End Interface

    [ InterfaceId ("E93DCF6C-4B07-4E1E-8123-AA16ED6EADF5") ]
    [ OleAutomation (False) ]
    Interface IMFMediaTypeHandler Extends stdole.IUnknown
        Function IsMediaTypeSupported(ByVal pMediaType As IMFMediaType) As IMFMediaType
        Function GetMediaTypeCount() As Long
        Function GetMediaTypeByIndex(ByVal dwIndex As Long) As IMFMediaType
        Sub SetCurrentMediaType(ByVal pMediaType As IMFMediaType)
        Function GetCurrentMediaType() As IMFMediaType
        Function GetMajorType() As UUID
    End Interface

    [ InterfaceId ("44AE0FA8-EA31-4109-8D2E-4CAE4997C555") ]
    [ OleAutomation (False) ]
    Interface IMFMediaType Extends IMFAttributes
        Function GetMajorType() As stdole.GUID
        Function IsCompressedFormat() As Long
        Function IsEqual(ByVal pIMediaType As IMFMediaType) As Long
        #If Win64 Then
        Sub GetRepresentation(guidRepresentation As UUID, ByRef ppvRepresentation As Any)
        Sub FreeRepresentation(guidRepresentation As UUID, ByRef pvRepresentation As Any)
        #Else
        Sub GetRepresentation(ByVal guidRepresentation1 As Long, ByVal guidRepresentation2 As Long, ByVal guidRepresentation3 As Long, ByVal guidRepresentation4 As Long, ByRef ppvRepresentation As Any)
        Sub FreeRepresentation(ByVal guidRepresentation1 As Long, ByVal guidRepresentation2 As Long, ByVal guidRepresentation3 As Long, ByVal guidRepresentation4 As Long, ByRef pvRepresentation As Any)
        #End If
    End Interface

    [ InterfaceId ("70AE66F2-C809-4E4F-8915-BDCB406B7993") ]
    [ OleAutomation (False) ]
    Interface IMFSourceReader Extends stdole.IUnknown
        Function GetStreamSelection(ByVal dwStreamIndex As Long) As Long
        Sub SetStreamSelection(ByVal dwStreamIndex As Long, ByVal fSelected As Long)
        Function GetNativeMediaType(ByVal dwStreamIndex As Long, ByVal dwMediaTypeIndex As Long) As IMFMediaType
        Function GetCurrentMediaType(ByVal dwStreamIndex As Long) As IMFMediaType
        Sub SetCurrentMediaType(ByVal dwStreamIndex As Long, ByVal pdwReserved As Long, ByVal pMediaType As IMFMediaType)
        Sub SetCurrentPosition(ByRef guidTimeFormat As UUID, ByRef varPosition As Variant)
        Function ReadSample(ByVal dwStreamIndex As Long, ByVal dwControlFlags As Long, ByRef pdwActualStreamIndex As Long, ByRef pdwStreamFlags As Long, ByRef pllTimestamp As LongLong) As IMFSample
        Sub Flush(ByVal dwStreamIndex As Long)
        Sub GetServiceForStream(ByVal dwStreamIndex As Long, ByRef guidService As UUID, ByRef riid As UUID, ByRef ppvObject As Any)
        Function GetPresentationAttribute(ByVal dwStreamIndex As Long, ByRef guidAttribute As UUID) As Variant
    End Interface

    [ InterfaceId ("C40A00F2-B93A-4D80-AE8C-5A1C634F58E4") ]
    [ OleAutomation (False) ]
    Interface IMFSample Extends IMFAttributes
        Function GetSampleFlags() As Long
        Sub SetSampleFlags(ByVal dwSampleFlags As Long)
        Function GetSampleTime() As LongLong
        Sub SetSampleTime(ByVal hnsSampleTime As LongLong)
        Function GetSampleDuration() As LongLong
        Sub SetSampleDuration(ByVal hnsSampleDuration As LongLong)
        Function GetBufferCount() As Long
        Function GetBufferByIndex(ByVal dwIndex As Long) As IMFMediaBuffer
        Function ConvertToContiguousBuffer() As IMFMediaBuffer
        Sub AddBuffer(ByVal pBuffer As IMFMediaBuffer)
        Sub RemoveBufferByIndex(ByVal dwIndex As Long)
        Sub RemoveAllBuffers()
        Function GetTotalLength() As Long
        Sub CopyToBuffer(ByVal pBuffer As IMFMediaBuffer)
    End Interface

    [ InterfaceId ("045FA593-8799-42B8-BC8D-8968C6453507") ]
    [ OleAutomation (False) ]
    Interface IMFMediaBuffer Extends stdole.IUnknown
        Sub Lock(ByRef ppbBuffer As Any, ByRef pcbMaxLength As Long, ByRef pcbCurrentLength As Long)
        Sub Unlock()
        Function GetCurrentLength() As Long
        Sub SetCurrentLength(ByVal cbCurrentLength As Long)
        Function GetMaxLength() As Long
    End Interface

    [ InterfaceId ("2EB1E945-18B8-4139-9B1A-D5D584818530") ]
    [ OleAutomation (False) ]
    Interface IMFClock Extends stdole.IUnknown
        Sub GetClockCharacteristics(ByRef pdwCharacteristics As Long)
        Sub GetCorrelatedTime(ByVal dwReserved As Long, ByRef pllClockTime As LongLong, ByRef phnsSystemTime As LongLong)
        Sub GetContinuityKey(ByRef pdwContinuityKey As Long)
        Sub GetState(ByVal dwReserved As Long, ByRef peClockState As MFCLOCK_STATE)
        Sub GetProperties(ByRef pClockProperties As MFCLOCK_PROPERTIES)
    End Interface

    [ InterfaceId ("5BC8A76B-869A-46A3-9B03-FA218A66AEBE") ]
    [ OleAutomation (False) ]
    Interface IMFCollection Extends stdole.IUnknown
        Sub GetElementCount(ByRef pcElements As Long)
        Sub GetElement(ByVal dwElementIndex As Long, ByRef ppUnkElement As stdole.IUnknown)
        Sub AddElement(ByVal pUnkElement As stdole.IUnknown)
        Sub RemoveElement(ByVal dwElementIndex As Long, ByRef ppUnkElement As stdole.IUnknown)
        Sub InsertElementAt(ByVal dwIndex As Long, ByVal pUnknown As stdole.IUnknown)
        Sub RemoveAllElements()
    End Interface

    [ InterfaceId ("7DC9D5F9-9ED9-44EC-9BBF-0600BB589FBB") ]
    [ OleAutomation (False) ]
    Interface IMF2DBuffer Extends stdole.IUnknown
        Sub Lock2D(ByRef pbScanline0 As Any, ByRef plPitch As Long)
        Sub Unlock2D()
        Sub GetScanline0AndPitch(ByRef pbScanline0 As Any, ByRef plPitch As Long)
        Sub IsContiguousFormat(ByVal pfIsContiguous As Long)
        Sub GetContiguousLength(ByRef pcbLength As Long)
        Sub ContiguousCopyTo(ByRef pbDestBuffer As Byte, ByVal cbDestBuffer As Long)
        Sub ContiguousCopyFrom(ByRef pbSrcBuffer As Any, ByVal cbSrcBuffer As Long)
    End Interface

    [ InterfaceId ("33AE5EA6-4316-436F-8DDD-D73D22F829EC") ]
    [ OleAutomation (False) ]
    Interface IMF2DBuffer2 Extends IMF2DBuffer
        Sub Lock2DSize(ByVal flags As MF2DBuffer_LockFlags, ByRef scanline0 As Byte, ByRef pitch As Long, ByRef buffer_start As Byte, ByRef buffer_length As Long)
        Sub Copy2DTo(ByVal dest_buffer As IMF2DBuffer2)
    End Interface

    [ InterfaceId ("E7174CFA-1C9E-48B1-8866-626226BFC258") ]
    [ OleAutomation (False) ]
    Interface IMFDXGIBuffer Extends stdole.IUnknown
        Sub GetResource(ByRef riid As UUID, ByRef object As Any)
        Sub GetSubresourceIndex(ByRef index As Long)
        Sub GetUnknown(ByRef guid As UUID, ByRef riid As UUID, ByRef object As Any)
        Sub SetUnknown(ByRef guid As UUID, ByVal data As stdole.IUnknown)
    End Interface

    [ InterfaceId ("83CF873A-F6DA-4BC8-823F-BACFD55DC430") ]
    [ OleAutomation (False) ]
    Interface IMFTopologyNode Extends IMFAttributes
        Sub SetObject(ByVal pObject As IUnknown)
        Sub GetObject(ByRef ppObject As IUnknown)
        Sub GetNodeType(ByRef pType As MF_TOPOLOGY_TYPE)
        Sub GetTopoNodeID(ByRef pid As LongLong)
        Sub SetTopoNodeID(ByVal ullTopoID As LongLong)
        Sub GetInputCount(ByRef pcInputs As Long)
        Sub GetOutputCount(ByRef pcOutputs As Long)
        Sub ConnectOutput(ByVal dwOutputIndex As Long, ByVal pDownstreamNode As IMFTopologyNode, ByVal dwInputIndexOnDownstreamNode As Long)
        Sub DisconnectOutput(ByVal dwOutputIndex As Long)
        Sub GetInput(ByVal dwInputIndex As Long, ByRef ppUpstreamNode As IMFTopologyNode, ByRef pdwOutputIndexOnUpstreamNode As Long)
        Sub GetOutput(ByVal dwOutputIndex As Long, ByRef ppDownstreamNode As IMFTopologyNode, ByRef pdwInputIndexOnDownstreamNode As Long)
        Sub SetOutputPrefType(ByVal dwOutputIndex As Long, ByVal pType As IMFMediaType)
        Sub GetOutputPrefType(ByVal dwOutputIndex As Long, ByRef ppType As IMFMediaType)
        Sub SetInputPrefType(ByVal dwInputIndex As Long, ByVal pType As IMFMediaType)
        Sub GetInputPrefType(ByVal dwInputIndex As Long, ByRef ppType As IMFMediaType)
        Sub CloneFrom(ByVal pNode As IMFTopologyNode)
    End Interface

    [ InterfaceId ("83CF873A-F6DA-4BC8-823F-BACFD55DC433") ]
    [ OleAutomation (False) ]
    Interface IMFTopology Extends IMFAttributes
        Sub GetTopologyID(ByRef pid As LongLong)
        Sub AddNode(ByVal pNode As IMFTopologyNode)
        Sub RemoveNode(ByVal pNode As IMFTopologyNode)
        Sub GetNodeCount(ByRef pwNodes As Integer)
        Sub GetNode(ByVal wIndex As Integer, ByRef ppNode As IMFTopologyNode)
        Sub Clear()
        Sub CloneFrom(ByVal pTopology As IMFTopology)
        Sub GetNodeByID(ByVal qwTopoNodeID As LongLong, ByRef ppNode As IMFTopologyNode)
        Sub GetSourceNodeCollection(ByRef ppCollection As IMFCollection)
        Sub GetOutputNodeCollection(ByRef ppCollection As IMFCollection)
    End Interface
    
    
Module slMF

Public Enum MF_ATTRIBUTE_SERIALIZE_OPTIONS
	MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF = &H00000001
End Enum

Public Enum MFSESSION_SETTOPOLOGY_FLAGS
	MFSESSION_SETTOPOLOGY_IMMEDIATE = &H1
	MFSESSION_SETTOPOLOGY_NORESOLUTION = &H2
	MFSESSION_SETTOPOLOGY_CLEAR_CURRENT = &H4
End Enum

Public Enum MFSESSION_GETFULLTOPOLOGY_FLAGS
	MFSESSION_GETFULLTOPOLOGY_CURRENT = &H1
End Enum

Public Enum MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS
	MF_TOPOLOGY_RESOLUTION_SUCCEEDED = &H00000000
	MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE = &H00000001
	MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS = &H00000002
End Enum

Public Enum MF_RESOLUTION
	' 
	'  Object type requested
	' 
	MF_RESOLUTION_MEDIASOURCE = &H00000001 ' Attempt to return a MediaSource object
	MF_RESOLUTION_BYTESTREAM = &H00000002 ' Attempt to return a ByteStream object (not currently supported)
	MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE = &H00000010
	MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL = &H00000020
	MF_RESOLUTION_DISABLE_LOCAL_PLUGINS = &H00000040
	MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY = &H00000080
	MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY = &H00000100
	MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE = &H00000200
	MF_RESOLUTION_ENABLE_STORE_PLUGINS = &H00000400
	MF_RESOLUTION_READ = &H00010000
	MF_RESOLUTION_WRITE = &H00020000
End Enum
Public Enum MFVideoInterlaceMode
	MFVideoInterlace_Unknown = 0
	MFVideoInterlace_Progressive = 2
	MFVideoInterlace_FieldInterleavedUpperFirst = 3
	MFVideoInterlace_FieldInterleavedLowerFirst = 4
	MFVideoInterlace_FieldSingleUpper = 5
	MFVideoInterlace_FieldSingleLower = 6
	MFVideoInterlace_MixedInterlaceOrProgressive = 7
	MFVideoInterlace_Last = 8
	MFVideoInterlace_ForceDWORD = &H7fffffff
End Enum

Public Enum MF_OBJECT_TYPE
	MF_OBJECT_MEDIASOURCE = 0
	MF_OBJECT_BYTESTREAM = 1
	MF_OBJECT_INVALID = 2
End Enum

Public Enum MF_ATTRIBUTE_TYPE
	MF_ATTRIBUTE_UINT32 = 19
	MF_ATTRIBUTE_UINT64 = 21
	MF_ATTRIBUTE_DOUBLE = 5
	MF_ATTRIBUTE_GUID = 72
	MF_ATTRIBUTE_STRING = 31
	MF_ATTRIBUTE_BLOB = 4113
	MF_ATTRIBUTE_IUNKNOWN = 13
End Enum

Public Enum MF_ATTRIBUTES_MATCH_TYPE
	MF_ATTRIBUTES_MATCH_OUR_ITEMS = 0
	MF_ATTRIBUTES_MATCH_THEIR_ITEMS = 1
	MF_ATTRIBUTES_MATCH_ALL_ITEMS = 2
	MF_ATTRIBUTES_MATCH_INTERSECTION = 3
	MF_ATTRIBUTES_MATCH_SMALLER = 4
End Enum

Public Enum MFBYTESTREAM_SEEK_ORIGIN
	msoBegin = 0
	msoCurrent = 1
End Enum

Public Enum MediaEventType
	MEUnknown = 0
	MEError = 1
	MEExtendedType = 2
	MENonFatalError = 3
	MEGenericV1Anchor = 3
	MESessionUnknown = 100
	MESessionTopologySet = 101
	MESessionTopologiesCleared = 102
	MESessionStarted = 103
	MESessionPaused = 104
	MESessionStopped = 105
	MESessionClosed = 106
	MESessionEnded = 107
	MESessionRateChanged = 108
	MESessionScrubSampleComplete = 109
	MESessionCapabilitiesChanged = 110
	MESessionTopologyStatus = 111
	MESessionNotifyPresentationTime = 112
	MENewPresentation = 113
	MELicenseAcquisitionStart = 114
	MELicenseAcquisitionCompleted = 115
	MEIndividualizationStart = 116
	MEIndividualizationCompleted = 117
	MEEnablerProgress = 118
	MEEnablerCompleted = 119
	MEPolicyError = 120
	MEPolicyReport = 121
	MEBufferingStarted = 122
	MEBufferingStopped = 123
	MEConnectStart = 124
	MEConnectEnd = 125
	MEReconnectStart = 126
	MEReconnectEnd = 127
	MERendererEvent = 128
	MESessionStreamSinkFormatChanged = 129
	MESessionV1Anchor = 129
	MESourceUnknown = 200
	MESourceStarted = 201
	MEStreamStarted = 202
	MESourceSeeked = 203
	MEStreamSeeked = 204
	MENewStream = 205
	MEUpdatedStream = 206
	MESourceStopped = 207
	MEStreamStopped = 208
	MESourcePaused = 209
	MEStreamPaused = 210
	MEEndOfPresentation = 211
	MEEndOfStream = 212
	MEMediaSample = 213
	MEStreamTick = 214
	MEStreamThinMode = 215
	MEStreamFormatChanged = 216
	MESourceRateChanged = 217
	MEEndOfPresentationSegment = 218
	MESourceCharacteristicsChanged = 219
	MESourceRateChangeRequested = 220
	MESourceMetadataChanged = 221
	MESequencerSourceTopologyUpdated = 222
	MESourceV1Anchor = 222
	MESinkUnknown = 300
	MEStreamSinkStarted = 301
	MEStreamSinkStopped = 302
	MEStreamSinkPaused = 303
	MEStreamSinkRateChanged = 304
	MEStreamSinkRequestSample = 305
	MEStreamSinkMarker = 306
	MEStreamSinkPrerolled = 307
	MEStreamSinkScrubSampleComplete = 308
	MEStreamSinkFormatChanged = 309
	MEStreamSinkDeviceChanged = 310
	MEQualityNotify = 311
	MESinkInvalidated = 312
	MEAudioSessionNameChanged = 313
	MEAudioSessionVolumeChanged = 314
	MEAudioSessionDeviceRemoved = 315
	MEAudioSessionServerShutdown = 316
	MEAudioSessionGroupingParamChanged = 317
	MEAudioSessionIconChanged = 318
	MEAudioSessionFormatChanged = 319
	MEAudioSessionDisconnected = 320
	MEAudioSessionExclusiveModeOverride = 321
	MESinkV1Anchor = 321
	METrustUnknown = 400
	MEPolicyChanged = 401
	MEContentProtectionMessage = 402
	MEPolicySet = 403
	METrustV1Anchor = 403
	MEWMDRMLicenseBackupCompleted = 500
	MEWMDRMLicenseBackupProgress = 501
	MEWMDRMLicenseRestoreCompleted = 502
	MEWMDRMLicenseRestoreProgress = 503
	MEWMDRMLicenseAcquisitionCompleted = 506
	MEWMDRMIndividualizationCompleted = 508
	MEWMDRMIndividualizationProgress = 513
	MEWMDRMProximityCompleted = 514
	MEWMDRMLicenseStoreCleaned = 515
	MEWMDRMRevocationDownloadCompleted = 516
	MEWMDRMV1Anchor = 516
	METransformUnknown = 600
	METransformNeedInput = 601
	METransformHaveOutput = 602
	METransformDrainComplete = 603
	METransformMarker = 604
	MEReservedMax = 10000
End Enum

Public Enum MF2DBuffer_LockFlags
	MF2DBuffer_LockFlags_LockTypeMask = &H3 '0x1 | 0x2 | 0x3,
	MF2DBuffer_LockFlags_Read = &H1
	MF2DBuffer_LockFlags_Write = &H2
	MF2DBuffer_LockFlags_ReadWrite = &H3
	MF2DBuffer_LockFlags_ForceDWORD = &H7fffffff
End Enum

Public Enum MFTOPOLOGY_DXVA_MODE
	' / <summary>
	' /     Default DXVA handling for MF v1.  The D3DManager will be set on
	' /     decoders inserted by the topoloader only.
	' / </summary>
	MFTOPOLOGY_DXVA_DEFAULT = 0
	' / <summary>
	' /     No DXVA.  No transforms will get the D3DManager.  This allows
	' /     software processing even on DXVA-enabled machines
	' / </summary>
	MFTOPOLOGY_DXVA_NONE = 1
	' / <summary>
	' /     Full DXVA.  The D3DManager will be set on any chain of D3D-aware
	' /     nodes upstream from a D3D-aware renderer.
	MFTOPOLOGY_DXVA_FULL = 2
End Enum

Public Enum MFTOPOLOGY_HARDWARE_MODE
	' / <summary>
	' /     Default hardware handling for MF v1.  Hardware MFTs will
	' /     not be inserted.
	' / </summary>
	MFTOPOLOGY_HWMODE_SOFTWARE_ONLY = 0
	' / <summary>
	' /     If hardware MFTs are available, the topoloader will insert
	' /     them.  If not, the topoloader will fall back to a software
	' /     MFT to perform the task.
	' / </summary>
	MFTOPOLOGY_HWMODE_USE_HARDWARE = 1
	' / <summary>
	' /     If hardware MFTs are available, the topoloader will insert
	' /     them.  If not, the connection will fail.
	' / </summary>
	MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE = 2
End Enum

Public Enum MF_TOPOLOGY_TYPE
	' / <member name="MF_TOPOLOGY_OUTPUT_NODE">
	' /     It represents the output topolgy node. The object contained in the output node could be a media sink object or an sink activator object.
	' / </member>
	MF_TOPOLOGY_OUTPUT_NODE = 0
	' / <member name="MF_TOPOLOGY_SOURCESTREAM_NODE">
	' /     It represents the source topology node. The node of this type implements IMFSourceStreamTopologyNode.
	' / </member>
	MF_TOPOLOGY_SOURCESTREAM_NODE = 1
	' / <member name="MF_TOPOLOGY_TRANSFORM_NODE">
	' /     It represents a media foundation transform object. The node of this type contains an IMFTransform object.
	' / </member>
	MF_TOPOLOGY_TRANSFORM_NODE = 2
	' / <member name="MF_TOPOLOGY_TEE_NODE">
	' /     represents a TEE node. It doesn't hold any real object. The node will be useful in scenarios like preview & archive.
	' / </member>
	MF_TOPOLOGY_TEE_NODE = 3
	MF_TOPOLOGY_MAX = &Hffffffff
End Enum

Public Enum MFCLOCK_CHARACTERISTICS_FLAGS
	' / <member name="MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ">
	' /     If set, clock times given in IMFClock::GetCorrelatedTime
	' /     are in standard MFTIME (100ns) units.
	' /     The dwClockFrequency member of the MFCLOCK_PROPERTIES structure
	' /     returned from IMFClock::GetProperties must be set to
	' /     MFCLOCK_FREQUENCY_HNS in this case.
	' / </member>
	MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ = &H2
	' / <member name="MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING">
	' /     If set, the clock will always be in the MFCLOCK_STATE_RUNNING
	' /     state.
	' / </member>
	MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING = &H4
	' / <member name="MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK">
	' /     If set, then this clock is running according to system time.
	' /     Therefore, the clock time returned from
	' /     IMFClock::GetCorrelation can be used without any further
	' /     calculations.
	' / </member>
	MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK = &H8
End Enum

Public Enum MFCLOCK_STATE
	' / <member name="MFCLOCK_STATE_INVALID">
	' /     Clock is currently invalid.
	' /     If the clock uses an underlying device, this could mean that
	' /     there is no device.
	' / </member>
	MFCLOCK_STATE_INVALID = 0
	' / <member name="MFCLOCK_STATE_RUNNING">
	' /     Clock is currently running (started).
	' / </member>
	MFCLOCK_STATE_RUNNING = 1
	' / <member name="MFCLOCK_STATE_STOPPED">
	' /     Clock is currently stopped and reporting a time of 0.
	' / </member>
	MFCLOCK_STATE_STOPPED = 2
	' / <member name="MFCLOCK_STATE_PAUSED">
	' /     Clock is currently paused, and the time it reports is frozen.
	' / </member>
	MFCLOCK_STATE_PAUSED = 3
End Enum

Public Enum MFCLOCK_RELATIONAL_FLAGS
	' / <member name="MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD">
	' /     If set, this bit indicates that jitter values are always negative.
	' /     That is, the clock time returned by IMFClock::GetCorrelatedTime()
	' /     will never jitter to times ahead; only to times behind.
	' / </member>
	MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD = &H1
End Enum

Public Type MFCLOCK_PROPERTIES
	'/ <member name="qwCorrelationRate">
	'/     The nominal rate at which the clock is correlated to MF system time.
	'/     A value of 0 means that the correlation is made during the
	'/     IMFClock::GetCorrelatedTime call.
	'/ </member>
	qwCorrelationRate As LongLong
	'/ <member name="guidClockId">
	'/     Uniquely identifies the clocking device (source crystal).
	'/     If two clocks have the same guidClockId, then they are based
	'/     on the same clocking device.
	'/     A value of GUID_NULL indicates that this clock is not similar
	'/     to any other clock.
	'/ </member>
	guidClockId As UUID
	'/ <member name="dwClockFlags">
	'/     Bit flags describing this clock.
	'/     See enumerated type MFCLOCK_RELATIONAL_FLAGS.
	'/ </member>
	dwClockFlags As Long
	'/ <member name="qwClockFrequency">
	'/     Fixed frequency in Hz at which the clock operates.
	'/     A value of MFCLOCK_FREQUENCY_HNS means that the clock has
	'/     a frequency of 10MHz, which is standard MFTIME units (100ns).
	'/     If the bit flag MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ
	'/     is set in the characteristics returned by
	'/     IMFClock::GetClockCharacteristics, then this value must be equal
	'/     to MFCLOCK_FREQUENCY_HNS.
	'/ </member>
	qwClockFrequency As LongLong
	'/ <member name="dwClockTolerance">
	'/     Amount of inaccuracy in parts-per-billion that may be present
	'/     on the clock.
	'/     Implementations that do not know the clock tolerance should
	'/     set this value to MFCLOCK_TOLERANCE_UNKNOWN, which is the
	'/     value typical in crystal specifications.
	'/ </member>
	dwClockTolerance As Long
	'/ <member name="dwClockJitter">
	'/     Amount of jitter in 100ns units that may be present on this
	'/     clock due to sampling (this does not include the inaccuracies
	'/     accounted for in dwClockTolerance).
	'/     For single-device clocks, this is the inverse of frequency.
	'/     For frequencies greater than or equal to 10MHz on single-device
	'/     clocks, this value should be 1.
	'/     When this clock belongs to a capture device that is not directly
	'/     timestamping the incoming data, the correlation cannot be made
	'/     until the driver's interrupt service routine runs.
	'/     If this is the case,
	'/     then these values should be included in the expected jitter:
	'/     <para>
	'/         MFCLOCK_JITTER_ISR:
	'/             Jitter due to timestamping during
	'/             the device driver's interrupt service routine.
	'/     </para>
	'/     <para>
	'/         MFCLOCK_JITTER_DPC:
	'/             Jitter due to timestampind during
	'/             the device driver's deferred procedure call processing.
	'/     </para>
	'/     <para>
	'/         MFCLOCK_JITTER_PASSIVE:
	'/             Jitter due to dropping to
	'/             passive level (normal thread execution) before timestamping.
	'/     </para>
	'/ </member>
	dwClockJitter As Long
End Type


Public Enum MFMEDIASOURCE_CHARACTERISTICS
	MFMEDIASOURCE_IS_LIVE = 0
	MFMEDIASOURCE_CAN_SEEK = 1
	MFMEDIASOURCE_CAN_PAUSE = 2
	MFMEDIASOURCE_HAS_SLOW_SEEK = 3
	MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS = 4
	MFMEDIASOURCE_CAN_SKIPFORWARD = 5
	MFMEDIASOURCE_CAN_SKIPBACKWARD = 6
	MFMEDIASOURCE_DOES_NOT_USE_NETWORK = 7
End Enum

Public Enum MF_SOURCE_READER_CONTROL_FLAG
	MF_SOURCE_READER_CONTROLF_DRAIN = 0
End Enum

Public Enum MF_SOURCE_READER_FLAG
	MF_SOURCE_READERF_ERROR = 0
	MF_SOURCE_READERF_ENDOFSTREAM = 1
	MF_SOURCE_READERF_NEWSTREAM = 2
	MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED = 3
	MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED = 4
	MF_SOURCE_READERF_STREAMTICK = 5
	MF_SOURCE_READERF_ALLEFFECTSREMOVED = 6
End Enum

[ Description ("Platform not initialized. Please call MFStartup().") ] Public Const MF_E_PLATFORM_NOT_INITIALIZED = &Hc00d36b0
[ Description ("The buffer was too small to carry out the requested action.") ] Public Const MF_E_BUFFERTOOSMALL = &Hc00d36b1
[ Description ("The request is invalid in the current state.") ] Public Const MF_E_INVALIDREQUEST = &Hc00d36b2
[ Description ("The stream number provided was invalid.") ] Public Const MF_E_INVALIDSTREAMNUMBER = &Hc00d36b3
[ Description ("The data specified for the media type is invalid, inconsistent, or not supported by this object.") ] Public Const MF_E_INVALIDMEDIATYPE = &Hc00d36b4
[ Description ("The callee is currently not accepting further input.") ] Public Const MF_E_NOTACCEPTING = &Hc00d36b5
[ Description ("This object needs to be initialized before the requested operation can be carried out.") ] Public Const MF_E_NOT_INITIALIZED = &Hc00d36b6
[ Description ("The requested representation is not supported by this object.") ] Public Const MF_E_UNSUPPORTED_REPRESENTATION = &Hc00d36b7
[ Description ("An object ran out of media types to suggest therefore the requested chain of streaming objects cannot be completed.") ] Public Const MF_E_NO_MORE_TYPES = &Hc00d36b9
[ Description ("The object does not support the specified service.") ] Public Const MF_E_UNSUPPORTED_SERVICE = &Hc00d36ba
[ Description ("An unexpected error has occurred in the operation requested.") ] Public Const MF_E_UNEXPECTED = &Hc00d36bb
[ Description ("Invalid name.") ] Public Const MF_E_INVALIDNAME = &Hc00d36bc
[ Description ("Invalid type.") ] Public Const MF_E_INVALIDTYPE = &Hc00d36bd
[ Description ("The file does not conform to the relevant file format specification.") ] Public Const MF_E_INVALID_FILE_FORMAT = &Hc00d36be
[ Description ("Invalid index.") ] Public Const MF_E_INVALIDINDEX = &Hc00d36bf
[ Description ("An invalid timestamp was given.") ] Public Const MF_E_INVALID_TIMESTAMP = &Hc00d36c0
[ Description ("The scheme of the given URL is unsupported.") ] Public Const MF_E_UNSUPPORTED_SCHEME = &Hc00d36c3
[ Description ("The byte stream type of the given URL is unsupported.") ] Public Const MF_E_UNSUPPORTED_BYTESTREAM_TYPE = &Hc00d36c4
[ Description ("The given time format is unsupported.") ] Public Const MF_E_UNSUPPORTED_TIME_FORMAT = &Hc00d36c5
[ Description ("The Media Sample does not have a timestamp.") ] Public Const MF_E_NO_SAMPLE_TIMESTAMP = &Hc00d36c8
[ Description ("The Media Sample does not have a duration.") ] Public Const MF_E_NO_SAMPLE_DURATION = &Hc00d36c9
[ Description ("The request failed because the data in the stream is corrupt.") ] Public Const MF_E_INVALID_STREAM_DATA = &Hc00d36cb
[ Description ("Real time services are not available.") ] Public Const MF_E_RT_UNAVAILABLE = &Hc00d36cf
[ Description ("The specified rate is not supported.") ] Public Const MF_E_UNSUPPORTED_RATE = &Hc00d36d0
[ Description ("This component does not support stream-thinning.") ] Public Const MF_E_THINNING_UNSUPPORTED = &Hc00d36d1
[ Description ("The call failed because no reverse playback rates are available.") ] Public Const MF_E_REVERSE_UNSUPPORTED = &Hc00d36d2
[ Description ("The requested rate transition cannot occur in the current state.") ] Public Const MF_E_UNSUPPORTED_RATE_TRANSITION = &Hc00d36d3
[ Description ("The requested rate change has been pre-empted and will not occur.") ] Public Const MF_E_RATE_CHANGE_PREEMPTED = &Hc00d36d4
[ Description ("The specified object or value does not exist.") ] Public Const MF_E_NOT_FOUND = &Hc00d36d5
[ Description ("The requested value is not available.") ] Public Const MF_E_NOT_AVAILABLE = &Hc00d36d6
[ Description ("The specified operation requires a clock and no clock is available.") ] Public Const MF_E_NO_CLOCK = &Hc00d36d7
[ Description ("This callback and state had already been passed in to this event generator earlier.") ] Public Const MF_S_MULTIPLE_BEGIN = &H000d36d8
[ Description ("This callback has already been passed in to this event generator.") ] Public Const MF_E_MULTIPLE_BEGIN = &Hc00d36d9
[ Description ("Some component is already listening to events on this event generator.") ] Public Const MF_E_MULTIPLE_SUBSCRIBERS = &Hc00d36da
[ Description ("This timer was orphaned before its callback time arrived.") ] Public Const MF_E_TIMER_ORPHANED = &Hc00d36db
[ Description ("A state transition is already pending.") ] Public Const MF_E_STATE_TRANSITION_PENDING = &Hc00d36dc
[ Description ("The requested state transition is unsupported.") ] Public Const MF_E_UNSUPPORTED_STATE_TRANSITION = &Hc00d36dd
[ Description ("An unrecoverable error has occurred.") ] Public Const MF_E_UNRECOVERABLE_ERROR_OCCURRED = &Hc00d36de
[ Description ("The provided sample has too many buffers.") ] Public Const MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS = &Hc00d36df
[ Description ("The provided sample is not writable.") ] Public Const MF_E_SAMPLE_NOT_WRITABLE = &Hc00d36e0
[ Description ("The specified key is not valid.") ] Public Const MF_E_INVALID_KEY = &Hc00d36e2
[ Description ("You are calling MFStartup with the wrong MF_VERSION. Mismatched bits?") ] Public Const MF_E_BAD_STARTUP_VERSION = &Hc00d36e3
[ Description ("The caption of the given URL is unsupported.") ] Public Const MF_E_UNSUPPORTED_CAPTION = &Hc00d36e4
[ Description ("The operation on the current offset is not permitted.") ] Public Const MF_E_INVALID_POSITION = &Hc00d36e5
[ Description ("The requested attribute was not found.") ] Public Const MF_E_ATTRIBUTENOTFOUND = &Hc00d36e6
[ Description ("The specified property type is not allowed in this context.") ] Public Const MF_E_PROPERTY_TYPE_NOT_ALLOWED = &Hc00d36e7
[ Description ("The specified property type is not supported.") ] Public Const MF_E_PROPERTY_TYPE_NOT_SUPPORTED = &Hc00d36e8
[ Description ("The specified property is empty.") ] Public Const MF_E_PROPERTY_EMPTY = &Hc00d36e9
[ Description ("The specified property is not empty.") ] Public Const MF_E_PROPERTY_NOT_EMPTY = &Hc00d36ea
[ Description ("The vector property specified is not allowed in this context.") ] Public Const MF_E_PROPERTY_VECTOR_NOT_ALLOWED = &Hc00d36eb
[ Description ("A vector property is required in this context.") ] Public Const MF_E_PROPERTY_VECTOR_REQUIRED = &Hc00d36ec
[ Description ("The operation is cancelled.") ] Public Const MF_E_OPERATION_CANCELLED = &Hc00d36ed
[ Description ("The provided bytestream was expected to be seekable and it is not.") ] Public Const MF_E_BYTESTREAM_NOT_SEEKABLE = &Hc00d36ee
[ Description ("The Media Foundation platform is disabled when the system is running in Safe Mode.") ] Public Const MF_E_DISABLED_IN_SAFEMODE = &Hc00d36ef
[ Description ("The Media Source could not parse the byte stream.") ] Public Const MF_E_CANNOT_PARSE_BYTESTREAM = &Hc00d36f0
[ Description ("Mutually exclusive flags have been specified to source resolver. This flag combination is invalid.") ] Public Const MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS = &Hc00d36f1
[ Description ("MediaProc is in the wrong state") ] Public Const MF_E_MEDIAPROC_WRONGSTATE = &Hc00d36f2
[ Description ("Real time I/O service can not provide requested throughput.") ] Public Const MF_E_RT_THROUGHPUT_NOT_AVAILABLE = &Hc00d36f3
[ Description ("The workqueue cannot be registered with more classes.") ] Public Const MF_E_RT_TOO_MANY_CLASSES = &Hc00d36f4
[ Description ("This operation cannot succeed because another thread owns this object.") ] Public Const MF_E_RT_WOULDBLOCK = &Hc00d36f5
[ Description ("Internal. Bitpump not found.") ] Public Const MF_E_NO_BITPUMP = &Hc00d36f6
[ Description ("No more RT memory available.") ] Public Const MF_E_RT_OUTOFMEMORY = &Hc00d36f7
[ Description ("An MMCSS class has not been set for this work queue.") ] Public Const MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED = &Hc00d36f8
[ Description ("Insufficient memory for response.") ] Public Const MF_E_INSUFFICIENT_BUFFER = &Hc00d7170
[ Description ("Activate failed to create mediasink. Call OutputNode::GetUINT32(MF_TOPONODE_MAJORTYPE) for more information. ") ] Public Const MF_E_CANNOT_CREATE_SINK = &Hc00d36fa
[ Description ("The length of the provided bytestream is unknown.") ] Public Const MF_E_BYTESTREAM_UNKNOWN_LENGTH = &Hc00d36fb
[ Description ("The media session cannot pause from a stopped state.") ] Public Const MF_E_SESSION_PAUSEWHILESTOPPED = &Hc00d36fc
[ Description ("The activate could not be created in the remote process for some reason it was replaced with empty one.") ] Public Const MF_S_ACTIVATE_REPLACED = &H000d36fd
[ Description ("The data specified for the media type is supported, but would require a format change, which is not supported by this object.") ] Public Const MF_E_FORMAT_CHANGE_NOT_SUPPORTED = &Hc00d36fe
[ Description ("The operation failed because an invalid combination of workqueue ID and flags was specified.") ] Public Const MF_E_INVALID_WORKQUEUE = &Hc00d36ff
[ Description ("No DRM support is available.") ] Public Const MF_E_DRM_UNSUPPORTED = &Hc00d3700
[ Description ("This operation is not authorized.") ] Public Const MF_E_UNAUTHORIZED = &Hc00d3701
[ Description ("The value is not in the specified or valid range.") ] Public Const MF_E_OUT_OF_RANGE = &Hc00d3702
[ Description ("The registered codec merit is not valid.") ] Public Const MF_E_INVALID_CODEC_MERIT = &Hc00d3703
[ Description ("Hardware MFT failed to start streaming due to lack of hardware resources.") ] Public Const MF_E_HW_MFT_FAILED_START_STREAMING = &Hc00d3704
[ Description ("Parsing is still in progress and is not yet complete.") ] Public Const MF_S_ASF_PARSEINPROGRESS = &H400d3a98
[ Description ("Not enough data have been parsed to carry out the requested action.") ] Public Const MF_E_ASF_PARSINGINCOMPLETE = &Hc00d3a98
[ Description ("There is a gap in the ASF data provided.") ] Public Const MF_E_ASF_MISSINGDATA = &Hc00d3a99
[ Description ("The data provided are not valid ASF.") ] Public Const MF_E_ASF_INVALIDDATA = &Hc00d3a9a
[ Description ("The packet is opaque, so the requested information cannot be returned.") ] Public Const MF_E_ASF_OPAQUEPACKET = &Hc00d3a9b
[ Description ("The requested operation failed since there is no appropriate ASF index.") ] Public Const MF_E_ASF_NOINDEX = &Hc00d3a9c
[ Description ("The value supplied is out of range for this operation.") ] Public Const MF_E_ASF_OUTOFRANGE = &Hc00d3a9d
[ Description ("The index entry requested needs to be loaded before it can be available.") ] Public Const MF_E_ASF_INDEXNOTLOADED = &Hc00d3a9e
[ Description ("The packet has reached the maximum number of payloads.") ] Public Const MF_E_ASF_TOO_MANY_PAYLOADS = &Hc00d3a9f
[ Description ("Stream type is not supported.") ] Public Const MF_E_ASF_UNSUPPORTED_STREAM_TYPE = &Hc00d3aa0
[ Description ("One or more ASF packets were dropped.") ] Public Const MF_E_ASF_DROPPED_PACKET = &Hc00d3aa1
[ Description ("There are no events available in the queue.") ] Public Const MF_E_NO_EVENTS_AVAILABLE = &Hc00d3e80
[ Description ("A media source cannot go from the stopped state to the paused state.") ] Public Const MF_E_INVALID_STATE_TRANSITION = &Hc00d3e82
[ Description ("The media stream cannot process any more samples because there are no more samples in the stream.") ] Public Const MF_E_END_OF_STREAM = &Hc00d3e84
[ Description ("The request is invalid because Shutdown() has been called.") ] Public Const MF_E_SHUTDOWN = &Hc00d3e85
[ Description ("The MP3 object was not found.") ] Public Const MF_E_MP3_NOTFOUND = &Hc00d3e86
[ Description ("The MP3 parser ran out of data before finding the MP3 object.") ] Public Const MF_E_MP3_OUTOFDATA = &Hc00d3e87
[ Description ("The file is not really a MP3 file.") ] Public Const MF_E_MP3_NOTMP3 = &Hc00d3e88
[ Description ("The MP3 file is not supported.") ] Public Const MF_E_MP3_NOTSUPPORTED = &Hc00d3e89
[ Description ("The Media stream has no duration.") ] Public Const MF_E_NO_DURATION = &Hc00d3e8a
[ Description ("The Media format is recognized but is invalid.") ] Public Const MF_E_INVALID_FORMAT = &Hc00d3e8c
[ Description ("The property requested was not found.") ] Public Const MF_E_PROPERTY_NOT_FOUND = &Hc00d3e8d
[ Description ("The property is read only.") ] Public Const MF_E_PROPERTY_READ_ONLY = &Hc00d3e8e
[ Description ("The specified property is not allowed in this context.") ] Public Const MF_E_PROPERTY_NOT_ALLOWED = &Hc00d3e8f
[ Description ("The media source is not started.") ] Public Const MF_E_MEDIA_SOURCE_NOT_STARTED = &Hc00d3e91
[ Description ("The Media format is recognized but not supported.") ] Public Const MF_E_UNSUPPORTED_FORMAT = &Hc00d3e98
[ Description ("The MPEG frame has bad CRC.") ] Public Const MF_E_MP3_BAD_CRC = &Hc00d3e99
[ Description ("The file is not protected.") ] Public Const MF_E_NOT_PROTECTED = &Hc00d3e9a
[ Description ("The media source is in the wrong state") ] Public Const MF_E_MEDIA_SOURCE_WRONGSTATE = &Hc00d3e9b
[ Description ("No streams are selected in source presentation descriptor.") ] Public Const MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED = &Hc00d3e9c
[ Description ("No key frame sample was found.") ] Public Const MF_E_CANNOT_FIND_KEYFRAME_SAMPLE = &Hc00d3e9d
[ Description ("An attempt to acquire a network resource failed.") ] Public Const MF_E_NETWORK_RESOURCE_FAILURE = &Hc00d4268
[ Description ("Error writing to the network.") ] Public Const MF_E_NET_WRITE = &Hc00d4269
[ Description ("Error reading from the network.") ] Public Const MF_E_NET_READ = &Hc00d426a
[ Description ("Internal. Entry cannot complete operation without network.") ] Public Const MF_E_NET_REQUIRE_NETWORK = &Hc00d426b
[ Description ("Internal. Async op is required.") ] Public Const MF_E_NET_REQUIRE_ASYNC = &Hc00d426c
[ Description ("Internal. Bandwidth levels are not supported.") ] Public Const MF_E_NET_BWLEVEL_NOT_SUPPORTED = &Hc00d426d
[ Description ("Internal. Stream groups are not supported.") ] Public Const MF_E_NET_STREAMGROUPS_NOT_SUPPORTED = &Hc00d426e
[ Description ("Manual stream selection is not supported.") ] Public Const MF_E_NET_MANUALSS_NOT_SUPPORTED = &Hc00d426f
[ Description ("Invalid presentation descriptor.") ] Public Const MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR = &Hc00d4270
[ Description ("Cannot find cache stream.") ] Public Const MF_E_NET_CACHESTREAM_NOT_FOUND = &Hc00d4271
[ Description ("The proxy setting is manual.") ] Public Const MF_I_MANUAL_PROXY = &H400d4272
[ Description ("Internal. Entry cannot complete operation without input.") ] Public Const MF_E_NET_REQUIRE_INPUT = &Hc00d4274
[ Description ("The client redirected to another server.") ] Public Const MF_E_NET_REDIRECT = &Hc00d4275
[ Description ("The client is redirected to a proxy server.") ] Public Const MF_E_NET_REDIRECT_TO_PROXY = &Hc00d4276
[ Description ("The client reached maximum redirection limit.") ] Public Const MF_E_NET_TOO_MANY_REDIRECTS = &Hc00d4277
[ Description ("The server, a computer set up to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.") ] Public Const MF_E_NET_TIMEOUT = &Hc00d4278
[ Description ("The control socket is closed by the client.") ] Public Const MF_E_NET_CLIENT_CLOSE = &Hc00d4279
[ Description ("The server received invalid data from the client on the control connection.") ] Public Const MF_E_NET_BAD_CONTROL_DATA = &Hc00d427a
[ Description ("The server is not a compatible streaming media server.") ] Public Const MF_E_NET_INCOMPATIBLE_SERVER = &Hc00d427b
[ Description ("Url.") ] Public Const MF_E_NET_UNSAFE_URL = &Hc00d427c
[ Description ("Data is not available.") ] Public Const MF_E_NET_CACHE_NO_DATA = &Hc00d427d
[ Description ("End of line.") ] Public Const MF_E_NET_EOL = &Hc00d427e
[ Description ("The request could not be understood by the server.") ] Public Const MF_E_NET_BAD_REQUEST = &Hc00d427f
[ Description ("The server encountered an unexpected condition which prevented it from fulfilling the request.") ] Public Const MF_E_NET_INTERNAL_SERVER_ERROR = &Hc00d4280
[ Description ("Session not found.") ] Public Const MF_E_NET_SESSION_NOT_FOUND = &Hc00d4281
[ Description ("There is no connection established with the Windows Media server. The operation failed.") ] Public Const MF_E_NET_NOCONNECTION = &Hc00d4282
[ Description ("The network connection has failed.") ] Public Const MF_E_NET_CONNECTION_FAILURE = &Hc00d4283
[ Description ("The Server service that received the HTTP push request is not a compatible version of Windows Media Services (WMS).") ] Public Const MF_E_NET_INCOMPATIBLE_PUSHSERVER = &Hc00d4284
[ Description ("The Windows Media server is denying access.  The username and/or password might be incorrect.") ] Public Const MF_E_NET_SERVER_ACCESSDENIED = &Hc00d4285
[ Description ("The proxy server is denying access.  The username and/or password might be incorrect.") ] Public Const MF_E_NET_PROXY_ACCESSDENIED = &Hc00d4286
[ Description ("Unable to establish a connection to the server.") ] Public Const MF_E_NET_CANNOTCONNECT = &Hc00d4287
[ Description ("The specified push template is invalid.") ] Public Const MF_E_NET_INVALID_PUSH_TEMPLATE = &Hc00d4288
[ Description ("The specified push publishing point is invalid.") ] Public Const MF_E_NET_INVALID_PUSH_PUBLISHING_POINT = &Hc00d4289
[ Description ("The requested resource is in use.") ] Public Const MF_E_NET_BUSY = &Hc00d428a
[ Description ("The Publishing Point or file on the Windows Media Server is no longer available.") ] Public Const MF_E_NET_RESOURCE_GONE = &Hc00d428b
[ Description ("The proxy experienced an error while attempting to contact the media server.") ] Public Const MF_E_NET_ERROR_FROM_PROXY = &Hc00d428c
[ Description ("The proxy did not receive a timely response while attempting to contact the media server.") ] Public Const MF_E_NET_PROXY_TIMEOUT = &Hc00d428d
[ Description ("The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.") ] Public Const MF_E_NET_SERVER_UNAVAILABLE = &Hc00d428e
[ Description ("The encoding process was unable to keep up with the amount of supplied data.") ] Public Const MF_E_NET_TOO_MUCH_DATA = &Hc00d428f
[ Description ("Session not found.") ] Public Const MF_E_NET_SESSION_INVALID = &Hc00d4290
[ Description ("The requested URL is not available in offline mode.") ] Public Const MF_E_OFFLINE_MODE = &Hc00d4291
[ Description ("A device in the network is blocking UDP traffic.") ] Public Const MF_E_NET_UDP_BLOCKED = &Hc00d4292
[ Description ("The specified configuration value is not supported.") ] Public Const MF_E_NET_UNSUPPORTED_CONFIGURATION = &Hc00d4293
[ Description ("The networking protocol is disabled.") ] Public Const MF_E_NET_PROTOCOL_DISABLED = &Hc00d4294
[ Description ("This object has already been initialized and cannot be re-initialized at this time.") ] Public Const MF_E_ALREADY_INITIALIZED = &Hc00d4650
[ Description ("The amount of data passed in exceeds the given bitrate and buffer window.") ] Public Const MF_E_BANDWIDTH_OVERRUN = &Hc00d4651
[ Description ("The sample was passed in too late to be correctly processed.") ] Public Const MF_E_LATE_SAMPLE = &Hc00d4652
[ Description ("The requested action cannot be carried out until the object is flushed and the queue is emptied.") ] Public Const MF_E_FLUSH_NEEDED = &Hc00d4653
[ Description ("The profile is invalid.") ] Public Const MF_E_INVALID_PROFILE = &Hc00d4654
[ Description ("The index that is being generated needs to be committed before the requested action can be carried out.") ] Public Const MF_E_INDEX_NOT_COMMITTED = &Hc00d4655
[ Description ("The index that is necessary for the requested action is not found.") ] Public Const MF_E_NO_INDEX = &Hc00d4656
[ Description ("The requested index cannot be added in-place to the specified ASF content.") ] Public Const MF_E_CANNOT_INDEX_IN_PLACE = &Hc00d4657
[ Description ("The ASF leaky bucket parameters must be specified in order to carry out this request.") ] Public Const MF_E_MISSING_ASF_LEAKYBUCKET = &Hc00d4658
[ Description ("The stream id is invalid. The valid range for ASF stream id is from 1 to 127.") ] Public Const MF_E_INVALID_ASF_STREAMID = &Hc00d4659
[ Description ("The requested Stream Sink has been removed and cannot be used.") ] Public Const MF_E_STREAMSINK_REMOVED = &Hc00d4a38
[ Description ("The various Stream Sinks in this Media Sink are too far out of sync for the requested action to take place.") ] Public Const MF_E_STREAMSINKS_OUT_OF_SYNC = &Hc00d4a3a
[ Description ("Stream Sinks cannot be added to or removed from this Media Sink because its set of streams is fixed.") ] Public Const MF_E_STREAMSINKS_FIXED = &Hc00d4a3b
[ Description ("The given Stream Sink already exists.") ] Public Const MF_E_STREAMSINK_EXISTS = &Hc00d4a3c
[ Description ("Sample allocations have been canceled.") ] Public Const MF_E_SAMPLEALLOCATOR_CANCELED = &Hc00d4a3d
[ Description ("The sample allocator is currently empty, due to outstanding requests.") ] Public Const MF_E_SAMPLEALLOCATOR_EMPTY = &Hc00d4a3e
[ Description ("When we try to sopt a stream sink, it is already stopped ") ] Public Const MF_E_SINK_ALREADYSTOPPED = &Hc00d4a3f
[ Description ("The ASF file sink could not reserve AVIO because the bitrate is unknown.") ] Public Const MF_E_ASF_FILESINK_BITRATE_UNKNOWN = &Hc00d4a40
[ Description ("No streams are selected in sink presentation descriptor.") ] Public Const MF_E_SINK_NO_STREAMS = &Hc00d4a41
[ Description ("The sink has not been finalized before shut down. This may cause sink generate a corrupted content.") ] Public Const MF_S_SINK_NOT_FINALIZED = &H000d4a42
[ Description ("A metadata item was too long to write to the output container.") ] Public Const MF_E_METADATA_TOO_LONG = &Hc00d4a43
[ Description ("The operation failed because no samples were processed by the sink.") ] Public Const MF_E_SINK_NO_SAMPLES_PROCESSED = &Hc00d4a44
[ Description ("There is no available procamp hardware with which to perform color correction.") ] Public Const MF_E_VIDEO_REN_NO_PROCAMP_HW = &Hc00d4e20
[ Description ("There is no available deinterlacing hardware with which to deinterlace the video stream.") ] Public Const MF_E_VIDEO_REN_NO_DEINTERLACE_HW = &Hc00d4e21
[ Description ("A video stream requires copy protection to be enabled, but there was a failure in attempting to enable copy protection.") ] Public Const MF_E_VIDEO_REN_COPYPROT_FAILED = &Hc00d4e22
[ Description ("A component is attempting to access a surface for sharing that is not shared.") ] Public Const MF_E_VIDEO_REN_SURFACE_NOT_SHARED = &Hc00d4e23
[ Description ("A component is attempting to access a shared device that is already locked by another component.") ] Public Const MF_E_VIDEO_DEVICE_LOCKED = &Hc00d4e24
[ Description ("The device is no longer available. The handle should be closed and a new one opened.") ] Public Const MF_E_NEW_VIDEO_DEVICE = &Hc00d4e25
[ Description ("A video sample is not currently queued on a stream that is required for mixing.") ] Public Const MF_E_NO_VIDEO_SAMPLE_AVAILABLE = &Hc00d4e26
[ Description ("No audio playback device was found.") ] Public Const MF_E_NO_AUDIO_PLAYBACK_DEVICE = &Hc00d4e84
[ Description ("The requested audio playback device is currently in use.") ] Public Const MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE = &Hc00d4e85
[ Description ("The audio playback device is no longer present.") ] Public Const MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED = &Hc00d4e86
[ Description ("The audio service is not running.") ] Public Const MF_E_AUDIO_SERVICE_NOT_RUNNING = &Hc00d4e87
[ Description ("The topology contains an invalid optional node.  Possible reasons are incorrect number of outputs and inputs or optional node is at the beginning or end of a segment. ") ] Public Const MF_E_TOPO_INVALID_OPTIONAL_NODE = &Hc00d520e
[ Description ("No suitable transform was found to decrypt the content. ") ] Public Const MF_E_TOPO_CANNOT_FIND_DECRYPTOR = &Hc00d5211
[ Description ("No suitable transform was found to encode or decode the content. ") ] Public Const MF_E_TOPO_CODEC_NOT_FOUND = &Hc00d5212
[ Description ("Unable to find a way to connect nodes") ] Public Const MF_E_TOPO_CANNOT_CONNECT = &Hc00d5213
[ Description ("Unsupported operations in topoloader") ] Public Const MF_E_TOPO_UNSUPPORTED = &Hc00d5214
[ Description ("The topology or its nodes contain incorrectly set time attributes") ] Public Const MF_E_TOPO_INVALID_TIME_ATTRIBUTES = &Hc00d5215
[ Description ("The topology contains loops, which are unsupported in media foundation topologies") ] Public Const MF_E_TOPO_LOOPS_IN_TOPOLOGY = &Hc00d5216
[ Description ("A source stream node in the topology does not have a presentation descriptor") ] Public Const MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR = &Hc00d5217
[ Description ("A source stream node in the topology does not have a stream descriptor") ] Public Const MF_E_TOPO_MISSING_STREAM_DESCRIPTOR = &Hc00d5218
[ Description ("A stream descriptor was set on a source stream node but it was not selected on the presentation descriptor") ] Public Const MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED = &Hc00d5219
[ Description ("A source stream node in the topology does not have a source") ] Public Const MF_E_TOPO_MISSING_SOURCE = &Hc00d521a
[ Description ("The topology loader does not support sink activates on output nodes.") ] Public Const MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED = &Hc00d521b
[ Description ("The sequencer cannot find a segment with the given ID.") ] Public Const MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID = &Hc00d61ac
[ Description ("The context was canceled.") ] Public Const MF_S_SEQUENCER_CONTEXT_CANCELED = &H000d61ad
[ Description ("Cannot find source in source cache.") ] Public Const MF_E_NO_SOURCE_IN_CACHE = &Hc00d61ae
[ Description ("Cannot update topology flags.") ] Public Const MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM = &H000d61af
[ Description ("A valid type has not been set for this stream or a stream that it depends on.") ] Public Const MF_E_TRANSFORM_TYPE_NOT_SET = &Hc00d6d60
[ Description ("A stream change has occurred. Output cannot be produced until the streams have been renegotiated.") ] Public Const MF_E_TRANSFORM_STREAM_CHANGE = &Hc00d6d61
[ Description ("The transform cannot take the requested action until all of the input data it currently holds is processed or flushed.") ] Public Const MF_E_TRANSFORM_INPUT_REMAINING = &Hc00d6d62
[ Description ("The transform requires a profile but no profile was supplied or found.") ] Public Const MF_E_TRANSFORM_PROFILE_MISSING = &Hc00d6d63
[ Description ("The transform requires a profile but the supplied profile was invalid or corrupt.") ] Public Const MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT = &Hc00d6d64
[ Description ("The transform requires a profile but the supplied profile ended unexpectedly while parsing.") ] Public Const MF_E_TRANSFORM_PROFILE_TRUNCATED = &Hc00d6d65
[ Description ("The property ID does not match any property supported by the transform.") ] Public Const MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED = &Hc00d6d66
[ Description ("The variant does not have the type expected for this property ID.") ] Public Const MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG = &Hc00d6d67
[ Description ("An attempt was made to set the value on a read-only property.") ] Public Const MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE = &Hc00d6d68
[ Description ("The array property value has an unexpected number of dimensions.") ] Public Const MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM = &Hc00d6d69
[ Description ("The array or blob property value has an unexpected size.") ] Public Const MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG = &Hc00d6d6a
[ Description ("The property value is out of range for this transform.") ] Public Const MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE = &Hc00d6d6b
[ Description ("The property value is incompatible with some other property or mediatype set on the transform.") ] Public Const MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE = &Hc00d6d6c
[ Description ("The requested operation is not supported for the currently set output mediatype.") ] Public Const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE = &Hc00d6d6d
[ Description ("The requested operation is not supported for the currently set input mediatype.") ] Public Const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE = &Hc00d6d6e
[ Description ("The requested operation is not supported for the currently set combination of mediatypes.") ] Public Const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION = &Hc00d6d6f
[ Description ("The requested feature is not supported in combination with some other currently enabled feature.") ] Public Const MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES = &Hc00d6d70
[ Description ("The transform cannot produce output until it gets more input samples.") ] Public Const MF_E_TRANSFORM_NEED_MORE_INPUT = &Hc00d6d72
[ Description ("The requested operation is not supported for the current speaker configuration.") ] Public Const MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG = &Hc00d6d73
[ Description ("The transform cannot accept mediatype changes in the middle of processing.") ] Public Const MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING = &Hc00d6d74
[ Description ("The caller should not propagate this event to downstream components.") ] Public Const MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT = &H000d6d75
[ Description ("The input type is not supported for D3D device.") ] Public Const MF_E_UNSUPPORTED_D3D_TYPE = &Hc00d6d76
[ Description ("The caller does not appear to support this transform's asynchronous capabilities.") ] Public Const MF_E_TRANSFORM_ASYNC_LOCKED = &Hc00d6d77
[ Description ("An audio compression manager driver could not be initialized by the transform.") ] Public Const MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER = &Hc00d6d78
[ Description ("You are not allowed to open this file. Contact the content provider for further assistance.") ] Public Const MF_E_LICENSE_INCORRECT_RIGHTS = &Hc00d7148
[ Description ("The license for this media file has expired. Get a new license or contact the content provider for further assistance.") ] Public Const MF_E_LICENSE_OUTOFDATE = &Hc00d7149
[ Description ("You need a license to perform the requested operation on this media file.") ] Public Const MF_E_LICENSE_REQUIRED = &Hc00d714a
[ Description ("The licenses for your media files are corrupted. Contact Microsoft product support.") ] Public Const MF_E_DRM_HARDWARE_INCONSISTENT = &Hc00d714b
[ Description ("The APP needs to provide IMFContentProtectionManager callback to access the protected media file.") ] Public Const MF_E_NO_CONTENT_PROTECTION_MANAGER = &Hc00d714c
[ Description ("Client does not have rights to restore licenses.") ] Public Const MF_E_LICENSE_RESTORE_NO_RIGHTS = &Hc00d714d
[ Description ("Licenses are restricted and hence can not be backed up.") ] Public Const MF_E_BACKUP_RESTRICTED_LICENSE = &Hc00d714e
[ Description ("License restore requires machine to be individualized.") ] Public Const MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION = &Hc00d714f
[ Description ("Protection for stream is not required.") ] Public Const MF_S_PROTECTION_NOT_REQUIRED = &H000d7150
[ Description ("Component is revoked.") ] Public Const MF_E_COMPONENT_REVOKED = &Hc00d7151
[ Description ("Trusted functionality is currently disabled on this component.") ] Public Const MF_E_TRUST_DISABLED = &Hc00d7152
[ Description ("No Action is set on WMDRM Output Trust Authority.") ] Public Const MF_E_WMDRMOTA_NO_ACTION = &Hc00d7153
[ Description ("Action is already set on WMDRM Output Trust Authority.") ] Public Const MF_E_WMDRMOTA_ACTION_ALREADY_SET = &Hc00d7154
[ Description ("DRM Heaader is not available.") ] Public Const MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE = &Hc00d7155
[ Description ("Current encryption scheme is not supported.") ] Public Const MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED = &Hc00d7156
[ Description ("Action does not match with current configuration.") ] Public Const MF_E_WMDRMOTA_ACTION_MISMATCH = &Hc00d7157
[ Description ("Invalid policy for WMDRM Output Trust Authority.") ] Public Const MF_E_WMDRMOTA_INVALID_POLICY = &Hc00d7158
[ Description ("The policies that the Input Trust Authority requires to be enforced are unsupported by the outputs.") ] Public Const MF_E_POLICY_UNSUPPORTED = &Hc00d7159
[ Description ("The OPL that the license requires to be enforced are not supported by the Input Trust Authority.") ] Public Const MF_E_OPL_NOT_SUPPORTED = &Hc00d715a
[ Description ("The topology could not be successfully verified.") ] Public Const MF_E_TOPOLOGY_VERIFICATION_FAILED = &Hc00d715b
[ Description ("Signature verification could not be completed successfully for this component.") ] Public Const MF_E_SIGNATURE_VERIFICATION_FAILED = &Hc00d715c
[ Description ("Running this process under a debugger while using protected content is not allowed.") ] Public Const MF_E_DEBUGGING_NOT_ALLOWED = &Hc00d715d
[ Description ("MF component has expired.") ] Public Const MF_E_CODE_EXPIRED = &Hc00d715e
[ Description ("The current GRL on the machine does not meet the minimum version requirements.") ] Public Const MF_E_GRL_VERSION_TOO_LOW = &Hc00d715f
[ Description ("The current GRL on the machine does not contain any renewal entries for the specified revocation.") ] Public Const MF_E_GRL_RENEWAL_NOT_FOUND = &Hc00d7160
[ Description ("The current GRL on the machine does not contain any extensible entries for the specified extension GUID.") ] Public Const MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND = &Hc00d7161
[ Description ("The kernel isn't secure for high security level content.") ] Public Const MF_E_KERNEL_UNTRUSTED = &Hc00d7162
[ Description ("The response from protected environment driver isn't valid.") ] Public Const MF_E_PEAUTH_UNTRUSTED = &Hc00d7163
[ Description ("A non-PE process tried to talk to PEAuth.") ] Public Const MF_E_NON_PE_PROCESS = &Hc00d7165
[ Description ("We need to reboot the machine.") ] Public Const MF_E_REBOOT_REQUIRED = &Hc00d7167
[ Description ("Protection for this stream is not guaranteed to be enforced until the MEPolicySet event is fired.") ] Public Const MF_S_WAIT_FOR_POLICY_SET = &H000d7168
[ Description ("This video stream is disabled because it is being sent to an unknown software output.") ] Public Const MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT = &H000d7169
[ Description ("The GRL file is not correctly formed, it may have been corrupted or overwritten.") ] Public Const MF_E_GRL_INVALID_FORMAT = &Hc00d716a
[ Description ("The GRL file is in a format newer than those recognized by this GRL Reader.") ] Public Const MF_E_GRL_UNRECOGNIZED_FORMAT = &Hc00d716b
[ Description ("The GRL was reloaded and required all processes that can run protected media to restart.") ] Public Const MF_E_ALL_PROCESS_RESTART_REQUIRED = &Hc00d716c
[ Description ("The GRL was reloaded and the current process needs to restart.") ] Public Const MF_E_PROCESS_RESTART_REQUIRED = &Hc00d716d
[ Description ("The user space is untrusted for protected content play.") ] Public Const MF_E_USERMODE_UNTRUSTED = &Hc00d716e
[ Description ("PEAuth communication session hasn't been started.") ] Public Const MF_E_PEAUTH_SESSION_NOT_STARTED = &Hc00d716f
[ Description ("PEAuth's public key is revoked.") ] Public Const MF_E_PEAUTH_PUBLICKEY_REVOKED = &Hc00d7171
[ Description ("The GRL is absent.") ] Public Const MF_E_GRL_ABSENT = &Hc00d7172
[ Description ("The Protected Environment is trusted.") ] Public Const MF_S_PE_TRUSTED = &H000d7173
[ Description ("The Protected Environment is untrusted.") ] Public Const MF_E_PE_UNTRUSTED = &Hc00d7174
[ Description ("The Protected Environment Authorization service (PEAUTH) has not been started.") ] Public Const MF_E_PEAUTH_NOT_STARTED = &Hc00d7175
[ Description ("The sample protection algorithms supported by components are not compatible.") ] Public Const MF_E_INCOMPATIBLE_SAMPLE_PROTECTION = &Hc00d7176
[ Description ("No more protected environment sessions can be supported.") ] Public Const MF_E_PE_SESSIONS_MAXED = &Hc00d7177
[ Description ("WMDRM ITA does not allow protected content with high security level for this release.") ] Public Const MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED = &Hc00d7178
[ Description ("WMDRM ITA cannot allow the requested action for the content as one or more components is not properly signed.") ] Public Const MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED = &Hc00d7179
[ Description ("WMDRM ITA does not support the requested action.") ] Public Const MF_E_ITA_UNSUPPORTED_ACTION = &Hc00d717a
[ Description ("WMDRM ITA encountered an error in parsing the Secure Audio Path parameters.") ] Public Const MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS = &Hc00d717b
[ Description ("The Policy Manager action passed in is invalid.") ] Public Const MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS = &Hc00d717c
[ Description ("The structure specifying Output Protection Level is not the correct format.") ] Public Const MF_E_BAD_OPL_STRUCTURE_FORMAT = &Hc00d717d
[ Description ("WMDRM ITA does not recognize the Explicite Analog Video Output Protection guid specified in the license.") ] Public Const MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID = &Hc00d717e
[ Description ("IMFPMPHost object not available.") ] Public Const MF_E_NO_PMP_HOST = &Hc00d717f
[ Description ("WMDRM ITA could not initialize the Output Protection Level data.") ] Public Const MF_E_ITA_OPL_DATA_NOT_INITIALIZED = &Hc00d7180
[ Description ("WMDRM ITA does not recognize the Analog Video Output specified by the OTA.") ] Public Const MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT = &Hc00d7181
[ Description ("WMDRM ITA does not recognize the Digital Video Output specified by the OTA.") ] Public Const MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT = &Hc00d7182
[ Description ("The continuity key supplied is not currently valid.") ] Public Const MF_E_CLOCK_INVALID_CONTINUITY_KEY = &Hc00d9c40
[ Description ("No Presentation Time Source has been specified.") ] Public Const MF_E_CLOCK_NO_TIME_SOURCE = &Hc00d9c41
[ Description ("The clock is already in the requested state.") ] Public Const MF_E_CLOCK_STATE_ALREADY_SET = &Hc00d9c42
[ Description ("The clock has too many advanced features to carry out the request.") ] Public Const MF_E_CLOCK_NOT_SIMPLE = &Hc00d9c43
[ Description ("Timer::SetTimer returns this success code if called happened while timer is stopped. Timer is not going to be dispatched until clock is running") ] Public Const MF_S_CLOCK_STOPPED = &H000d9c44
[ Description ("The component does not support any more drop modes.") ] Public Const MF_E_NO_MORE_DROP_MODES = &Hc00da028
[ Description ("The component does not support any more quality levels.") ] Public Const MF_E_NO_MORE_QUALITY_LEVELS = &Hc00da029
[ Description ("The component does not support drop time functionality.") ] Public Const MF_E_DROPTIME_NOT_SUPPORTED = &Hc00da02a
[ Description ("Quality Manager needs to wait longer before bumping the Quality Level up.") ] Public Const MF_E_QUALITYKNOB_WAIT_LONGER = &Hc00da02b
[ Description ("Quality Manager is in an invalid state. Quality Management is off at this moment.") ] Public Const MF_E_QM_INVALIDSTATE = &Hc00da02c
[ Description ("No transcode output container type is specified.") ] Public Const MF_E_TRANSCODE_NO_CONTAINERTYPE = &Hc00da410
[ Description ("The profile does not have a media type configuration for any selected source streams.") ] Public Const MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS = &Hc00da411
[ Description ("Cannot find an encoder MFT that accepts the user preferred output type.") ] Public Const MF_E_TRANSCODE_NO_MATCHING_ENCODER = &Hc00da412
[ Description ("Memory allocator is not initialized.") ] Public Const MF_E_ALLOCATOR_NOT_INITIALIZED = &Hc00da7f8
[ Description ("Memory allocator is not committed yet.") ] Public Const MF_E_ALLOCATOR_NOT_COMMITED = &Hc00da7f9
[ Description ("Memory allocator has already been committed.") ] Public Const MF_E_ALLOCATOR_ALREADY_COMMITED = &Hc00da7fa
[ Description ("An error occurred in media stream.") ] Public Const MF_E_STREAM_ERROR = &Hc00da7fb
[ Description ("Stream is not in a state to handle the request.") ] Public Const MF_E_INVALID_STREAM_STATE = &Hc00da7fc
[ Description ("Hardware stream is not connected yet.") ] Public Const MF_E_HW_STREAM_NOT_CONNECTED = &Hc00da7fd
        
Public Const MF_VERSION = &H00020000
Public Const MFBYTESTREAM_SEEK_FLAG_CANCEL_PENDING_IO = 1
Public Const MFASYNC_FAST_IO_PROCESSING_CALLBACK = 1
Public Const MFASYNC_SIGNAL_CALLBACK = 2
Public Const MFASYNC_BLOCKING_CALLBACK = 4
Public Const MFASYNC_REPLY_CALLBACK = 8
Public Const MF_EVENT_FLAG_NO_WAIT = 1
Public Const MF_SOURCE_READER_FIRST_VIDEO_STREAM = &Hfffffffc
Public Const MF_SOURCE_READER_FIRST_AUDIO_STREAM = &Hfffffffd
Public Const MF_SOURCE_READER_CURRENT_TYPE_INDEX = &Hffffffff
Public Const MF_SOURCE_READER_ANY_STREAM = &Hffffffff
Public Const MF_SOURCE_READER_INVALID_STREAM_INDEX = &Hffffffff
Public Const MF_SOURCE_READER_ALL_STREAMS = &Hfffffffe
Public Const MF_SOURCE_READER_MEDIASOURCE = &Hffffffff
Public Const MF_MEDIATYPE_EQUAL_MAJOR_TYPES = 1
Public Const MF_MEDIATYPE_EQUAL_FORMAT_TYPES = 2
Public Const MF_MEDIATYPE_EQUAL_FORMAT_DATA = 4
Public Const MF_MEDIATYPE_EQUAL_FORMAT_USER_DATA = 8

        [ UseGetLastError (False) ]
        ' WARNING: [MFStartup] this is not an exact replica of the real TLB definition, as the function is declared with a feature that isn't currently supported in tB-syntax
Public Declare PtrSafe Function MFStartup Lib "MFPlat.DLL" (ByVal Version As Long, ByVal dwFlags As Long) As Long
        [ UseGetLastError (False) ]
        ' WARNING: [MFShutdown] this is not an exact replica of the real TLB definition, as the function is declared with a feature that isn't currently supported in tB-syntax
Public Declare PtrSafe Function MFShutdown Lib "MFPlat.DLL" () As Long
        [ UseGetLastError (False) ]
        ' WARNING: [MFCreateSourceResolver] this is not an exact replica of the real TLB definition, as the function is declared with a feature that isn't currently supported in tB-syntax
Public Declare PtrSafe Function MFCreateSourceResolver Lib "MFPlat.DLL" (ppISourceResolver As IMFSourceResolver) As Long
        [ UseGetLastError (False) ]
        ' WARNING: [MFCreateAttributes] this is not an exact replica of the real TLB definition, as the function is declared with a feature that isn't currently supported in tB-syntax
Public Declare PtrSafe Function MFCreateAttributes Lib "MFPlat.DLL" (ByRef ppMFAttributes As IMFAttributes, ByVal cInitialSize As Long) As Long
        [ UseGetLastError (False) ]
        ' WARNING: [MFCreateMediaType] this is not an exact replica of the real TLB definition, as the function is declared with a feature that isn't currently supported in tB-syntax
Public Declare PtrSafe Function MFCreateMediaType Lib "MFPlat.DLL" (ppMFMediaType As IMFMediaType) As Long
        
               
Public Declare PtrSafe Function MFCreateSourceReaderFromMediaSource Lib "MFReadWrite.DLL" (ByVal pMediaSource As IMFMediaSource, ByVal pAttributes As IMFAttributes, ppReader As IMFSourceReader) As Long

End Module